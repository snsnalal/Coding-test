# Coding-test
* [소수인지 판별](./1.java) <br><br>
* [DFS](./dfs.java) : 깊이 우선 탐색, 최대한 멀리있는 노드부터 탐색 <br>

* [BFS](./bfs.java) : 너비 우선 탐색, 바로 가까이 있는 노드부터 탐색<br>

* [선택 정렬](./Select_sort.java) : 매번 가장 작은 것을 선택, 시간복잡도 : O(N<sup>2</sup>)<br>

* [삽입 정렬](./Insert_sort.java) : 가장 느린 편, 데이터가 정렬되어 있는 상태라면 매우 빠르다.적절한 위치에 데이터를 삽입<br> 첫 번째 데이터는 정렬되어 있다고 판단, 시간복잡도 : O(N<sup>2</sup>) 최선의 경우 시간복잡도 : O(N)

* [퀵 정렬](./Quick_sort.java) : 기준(피벗)을 설정한 후 큰 수와 작은 수를 교환하고 리스트를 반으로 나눈다. 데이터가 무작위로 되어있을 경우 매우 빠르다. 평균 시간복잡도 : O(NlogN) 최악의 시간복잡도 : O(N<sup>2</sup>)

* [계수 정렬](./Count_sort.java) : 데이터의 크기 범위가 제한되어 정수 형태로 표한할 수 있을 때만 사용할 수 있다. 시간복잡도 : O(N + K) (N : 개수, K : 최댓값)

* [이진 탐색](./Binary_search.java) : 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교하여 원하는 데이터를 찾는다. 시간복잡도 : O(logN)

* [다이나믹 프로그래밍 Top_Down](./Dinamic_ttb.java) : 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 해결하는 방식. 시간복잡도 : O(N) <br>
* [다이나믹 프로그래밍 Bottom_Up](./Dinamic_btt.java) : 반복문을 이용, 작은 문제부터 차근차근 답을 도출한다. 시간복잡도 : O(N)

* [다익스트라 알고리즘](./Dijkstra.java) : 우선순위 큐를 사용, 한 지점에서 다른 특정 지점까지의 최단 경로를 구함, 방문하지 않은 노드 중 최단거리가 가장 짧은 노드를 선택. 시간복잡도 : O(ElogV) (E : 원소 개수, V : 노드 개수)

* [플로이드 워셜 알고리즘](./Floyd_warshall.java) : 모든 지점에서 다른 모든 지점까지의 최단 경로를 구하는 알고리즘, 시간복잡도 : O(N<sup>3</sup>) 점화식 : D<sub>ab</sub> = min(D<sub>ab</sub>, D<sub>ak</sub> + D<sub>kb</sub>)

* [서로소 집합 알고리즘](./Disjoint_set.java) : 무방향 그래프 내에서의 사이클을 판별할 때 사용할 수 있다는 특징, 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조, A와 B의 루트노드를 찾고 더 작은 것을 더 큰 것의 부모 노드로 설정한다. 시간복잡도 : O(V + M(1 + log<sub>2-M/v</sub>V))
* [서로소를 이용한 사이클 판별](./Cycle.java) : 루트 노드가 서로 다르면 union 연산 수행, 같으면 사이클이 발생, 무방향 그래프에만 적용 가능

* [크루스칼 알고리즘](./Kruskal.java) : 가능한 한 최소 비용으로 신장 트리를 찾아야 할 때 사용 가능(ex) N개의 도시중 2개의 도시를 연결 할 때 도로 비용이 최소가 될 수 있는 경우 탐색, 간선을 비용에 따라 오름차순으로 정렬한 후 하나씩 확인하며 사이클이 발생하지 않을 경우 신장트리에 포함시키고 반대일 경우(같은 union에 포함) 포함시키지 않는다.(간선의 개수 = 노드의 개수 -1) 시간복잡도 : O(ElogE) E : 간선의 개수

* [위상 정렬](./Topology_Sort.java) : 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것, 진입차수가 0인 노드를 큐에 넣고 큐에서 원소를 꺼내면서 해당 노드에 연결된 간선 제거 -> 새롭게 진입차수가 0이된 노드를 큐에 삽입, 시간복잡도 : O(V + E)
